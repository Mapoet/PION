/// \file silo2text.cc
/// \author Jonathan Mackey
/// 
/// This file reads in silo files generated by serial and parallel code
/// and re-writes the data as a single text file. 
///
/// Mods:
/// - 2011.12.14 JM: converted from silocompare.cc
/// - 2013.09.05 JM: Fixed for pion; added microphysics so ascii
///    files can have gas temperature written out.

#ifndef PARALLEL
# error "define PARALLEL so this will work!"
#endif

#include "defines/functionality_flags.h"
#include "defines/testing_flags.h"

#include <dirent.h>
#include <errno.h>
#include <list>
#include <iostream>
#include <sstream>
using namespace std;
#include "global.h"
#include "dataIO/dataio.h"
#include "dataIO/dataio_silo.h"
#include "grid/uniform_grid.h"
#include <silo.h>

#include "microphysics/microphysics_base.h"
#ifndef EXCLUDE_MPV1
#include "microphysics/microphysics.h"
#endif 
#ifndef EXCLUDE_HD_MODULE
#include "microphysics/microphysics_lowZ.h"
#endif 
#include "microphysics/mp_only_cooling.h"
#ifndef EXCLUDE_MPV2
#ifdef MP_V2_AIFA
#include "microphysics/mp_v2_aifa.h"
#endif
#endif 
#ifndef EXCLUDE_MPV3
#include "microphysics/mp_explicit_H.h"
#endif
#ifndef EXCLUDE_MPV4
#include "microphysics/mp_implicit_H.h"
#endif 

#include "microphysics/mpv5_molecular.h"
#include "microphysics/mpv6_PureH.h"
#include "microphysics/mpv7_TwoTempIso.h"

#ifdef CODE_EXT_HHE
#include "future/mpv9_HHe.h"
#endif

/** \brief choose variables to read (from dataio_silo.cc) */
void set_readvars(std::vector<string> &///< list of variables to add to.
		  );
/** \brief Given a Variable and a Silo File, read the data onto the grid. */
int read_variable2grid(DBfile *, ///< pointer to silo file.
		       const string,   ///< variable name to read.
		       const long int  ///< number of cells expected.
		       );

/** \brief get nproc and numfiles from the header, and returns an error
 * if it is a serial file (fails to find numfiles).
 */
int get_nproc_numfiles(const string, ///< name of file to open
		       int *,   ///< number of processes.
		       int *    ///< number of files per timestep
		       );

/** \brief Given a point, determine if it is on my local domain or not.
 * Returns true if it is. 
 */
bool point_on_my_domain(const cell * ///< pointer to cell
			);


///
/// Function to setup the microphysics class (just so I can calculate gas
/// temperature in a manner consistent with how it was done in the 
/// simulation).  Function copied from gridMethods.cc
///
int setup_microphysics();


//
// Return list of files in a given directory.
//
int get_dir_listing (const string dir,    ///< directory to list.
		     list<string> *files  ///< list to put filenames in.
		     )
{
  cout <<"get_dir_listing() reading directory: "<<dir<<endl;
  DIR *dp=0;
  struct dirent *dirp=0;
  if((dp  = opendir(dir.c_str())) == 0) {
    cout << "Error(" << errno << ") opening " << dir << endl;
    return errno;
  }
  
  while ((dirp = readdir(dp)) != 0) {
    //string temp=dirp->d_name;files->push_back(temp);
    files->push_back(string(dirp->d_name));
    //cout <<"\tget_dir_listing() file: "<<string(dirp->d_name)<<endl;
  }
  closedir(dp);
  cout <<"get_dir_listing() done."<<endl;
  return 0;
}

//
// Given a directory and a string to match files to (may be blank),
// return sorted list of files.
//
int get_files_in_dir(const string dir,    ///< directory to list.
		     const string str,    ///< string that files start with
		     list<string> *files  ///< list to put filenames in.
		     )
{
  cout <<"get_files_in_dir(): starting.\n";
  int err=0;
  if (!files->empty())
    cout <<"WARNING: list of files is not empty, adding to end of list.\n";

  //
  // get directory listing
  //
  err += get_dir_listing(dir,files);
  cout <<"get_files_in_dir(): got dir listing with "<<files->size()<<" elements.\n";

  //
  // remove elements that don't begin with a given substring
  //
  if (!str.empty()) {
    cout <<"get_files_in_dir(): looking for substring in filenames: "<<str<<endl;
    list<string>::iterator i=files->begin();
    cout <<"file i="<<*i<<"\n";
    if (i!=files->end()) { // check that dir listing is not empty...
      do {
	//if ((*i).find(str) == string::npos) {
	//
	// If filename doesn't start with str, then delete it.
	//
	if ((*i).find(str) != 0 || (*i).find("silo")==string::npos) {
	  //cout <<"removing file "<<*i<<" from list.\n";
	  files->erase(i);
	  //files->remove(i);
	  i=files->begin();
	}
	else i++;
      } while (i!=files->end());
    }
  }
  else
    cout <<"get_files_in_dir(): No substring, so not removing any elements. returning...\n";

  //
  // sort remaining elements.
  //
  files->sort();
  cout <<"get_files_in_dir(): done. found "<<files->size()<<" files.\n";
  return err;
}



int main(int argc, char **argv)
{

  //
  // First initialise MPI, even though this is a single processor
  // piece of code.
  //
  int err = COMM->init(&argc, &argv);

  //
  // Get an input file and an output file.
  //
  if (argc!=4) {
    cerr << "Error: must call as follows...\n";
    cerr << "silo2text: <silo2text> <source-dir> <file-base>  <output-file> \n";
    rep.error("Bad number of args",argc);
  }
  string fdir = argv[1];
  string firstfile= argv[2];
  string outfilebase =argv[3]; string outfile;

  string rts("msg_"); rts += outfilebase;
  //rep.redirect(rts);

  //
  // Get list of first and second files to read, and make sure they match.
  //
  list<string> ffiles;
  err += get_files_in_dir(fdir, firstfile,  &ffiles);
  if (err) rep.error("failed to get list of files",err);
  //for (list<string>::iterator s=ffiles.begin(); s!=ffiles.end(); s++)
  //  cout <<"firstfiles: "<<*s<<endl;
  //for (list<string>::iterator s=sfiles.begin(); s!=sfiles.end(); s++)
  //  cout <<"second files: "<<*s<<endl;
  //
  // Set up iterators to run through all the files.
  //
  list<string>::iterator ff=ffiles.begin();
  unsigned int nfiles = ffiles.size();
  
  //
  // loop over all files: open first and write a text file.
  //
  for (unsigned int fff=0; fff<nfiles; fff++) {
    ostringstream oo;
    oo.str(""); oo<<fdir<<"/"<<*ff; firstfile  =oo.str(); 

    class file_status fstat;
    if (!fstat.file_exists(firstfile)) {
       cout <<"first file: "<<firstfile<<"\n";
       rep.error("First file doesn't exist",firstfile);
    }
    
    //
    // Setup silo I/O classes.
    //
    bool
      ff_serial = true;
    class dataio_silo firstio;
    
    //
    // Read in first code header so i know how to setup grid.
    //
    err = firstio.ReadHeader(firstfile);
    if (err) rep.error("Didn't read header",err);
  
    //
    // Setup microphysics
    //
    if (fff==0) setup_microphysics();
    
    //
    // Set output file name.
    //
    oo.str(""); oo <<outfilebase<<"."; oo.fill('0'); oo.width(8); oo<<SimPM.timestep<<".txt";
    outfile = oo.str();
    cout <<"\n**************************************************************************************\n";
    cout <<"fff="<<fff<<"\tinput file: "<<firstfile<<"\toutput file: "<<outfile<<"\n";


    //
    // May need to setup extra data in each cell for ray-tracing optical
    // depths and/or viscosity variables (here just set it to zero).
    //
    CI.setup_extra_data(SimPM.RS,0,0);
    //
    // Setup grid.
    //
    if (grid) cout <<"grid already setup, so continuing.\n";
    else {
#ifdef CHECK_NEW_EXCEP_ON
      try {
	grid = new UniformGrid (SimPM.ndim, SimPM.nvar, SimPM.eqntype, SimPM.Xmin, SimPM.Xmax, SimPM.NG);
      }
      catch (std::bad_alloc) {
	rep.error("(IntUniformFV::setup_grid) Couldn't assign data!", grid);
      }
#else
      grid = new UniformGrid (SimPM.ndim, SimPM.nvar, SimPM.eqntype, SimPM.Xmin, SimPM.Xmax, SimPM.NG);
      if (grid==0) rep.error("(IntUniformFV::setup_grid) Couldn't assign data!", grid);
#endif
      cout <<"(silocompare::setup_grid) Done. g="<<grid<<"\n";
      cout <<"DX = "<<grid->DX()<<endl;
    }
    cout <<"DX = "<<grid->DX()<<endl;

    
    //
    // Read first file data onto grid; this may be serial or parallel, so we
    // need to decide first.
    //
    int nproc=0, numfiles=0, ngroups=0;
    err = get_nproc_numfiles(firstfile, &nproc, &numfiles);
    if (err) {
      //
      // must be reading serial file, so use serial ReadData() function:
      //
      ff_serial = true;
      ngroups   = 1;
      err = firstio.ReadData(firstfile,grid);
      rep.errorTest("(silocompare) Failed to read data",0,err);
    }
    else {
      //
      // must be reading parallel file, so want to read in every subdomain onto grid.
      // Use local functions for this:
      //
      ff_serial = false;
      ngroups   = nproc/numfiles;
      //
      // First loop over all files:
      //
      for (int ifile=0; ifile<numfiles; ifile++) {
	string infile = firstfile;
	//
	// If we have a parallel file, Parse filename, and replace file number 
	// with new ifile, store in name 'infile'.
	//
	ostringstream temp; 
	temp.fill('0');
	string::size_type pos = infile.find("_0000");
	if (pos==string::npos) {
	  cout <<"didn't find _0000 in file, but claim we are reading pllel file!\n";
	  rep.error("not a parallel i/o filename!",infile);
	}
	else {
	  temp.str("");temp<<"_";temp.width(4);temp<<ifile;
	  infile.replace(pos,5,temp.str());
	  cout <<"\tNew infile: "<<infile<<endl;
	  temp.str("");
	}

	DBfile *dbfile = DBOpen(infile.c_str(), SILO_FILETYPE, DB_READ);
	if (!dbfile) rep.error("open first silo file failed.",dbfile);
	//
	// loop over domains within this file.
	//
	for (int igroup=0; igroup<ngroups; igroup++) {
	  DBSetDir(dbfile,"/");
	  //
	  // choose myrank, and decompose domain accordingly.
	  //
	  mpiPM.myrank = ifile*ngroups +igroup;
	  mpiPM.decomposeDomain();
	  
	  
	  //
	  // set directory in file.
	  //
	  temp.str(""); temp << "rank_"; temp.width(4); temp << mpiPM.myrank << "_domain_";
	  temp.width(4); temp << igroup;
	  string mydir = temp.str(); temp.str("");
	  cout <<"\t\tdomain: "<<mydir<<endl;
	  DBSetDir(dbfile, mydir.c_str());

	  //
	  // set variables to read: (ripped from dataio_silo class)
	  //
	  std::vector<string> readvars;
	  set_readvars(readvars);
	  
	  //
	  // now read each variable in turn from the mesh
	  //
	  for (std::vector<string>::iterator i=readvars.begin(); i!=readvars.end(); ++i) {
	    err = read_variable2grid(dbfile, (*i), mpiPM.LocalNcell);
	    if (err)
	      rep.error("error reading variable",(*i));
	  }
	} // loop over domains within a file.
	
	//
	// Close this file
	//
	DBClose(dbfile);
	dbfile=0; 
      } // loop over files

    } // plell first file...
    
    //
    // Now put the data in c->Ph for first file:
    //
    cell *c = grid->FirstPt();
    do {
      for (int v=0; v<SimPM.nvar; v++)
	c->Ph[v] = c->P[v];
    } while ( (c=grid->NextPt(c))!=0);
    c = grid->FirstPt();
    rep.printVec("P ",c->P ,SimPM.nvar);
    rep.printVec("Ph",c->Ph,SimPM.nvar);

    cout <<"FINISHED reading first file: "<<firstfile<<endl;

    // ***************************************************************
    // ********* FINISHED FIRST FILE, MOVE ON TO OUTPUT FILE *********
    // ***************************************************************
    
    //
    // write difference to output file.
    //
    c=grid->FirstPt(); 
    
    class dataio_text textio;
    err += textio.OutputData(outfilebase, grid, SimPM.timestep);
    if (err) {cerr<<"\t Error writing data.\n"; return(1);}


    //
    // move onto next first and second files
    //
    ff++;
  } // move onto next file

  //
  // Finish up and quit.
  //
  COMM->finalise();
  delete COMM; COMM=0;
  delete MP; MP=0;
  //MPI_Finalize();
  return 0;
}


int get_nproc_numfiles(string fname, int *np, int *nf)
{
  int err=0;

  //
  // open file
  //
  cout <<"opening file: "<<fname<<endl;
  DBfile *dbfile = 0;
  dbfile = DBOpen(fname.c_str(), SILO_FILETYPE, DB_READ);
  if (!dbfile) rep.error("open silo file failed.",dbfile);
  
  //
  // read nproc, numfiles from header
  //
  DBSetDir(dbfile,"/header");
  int nproc=0, numfiles=0, ngroups=0;
  err += DBReadVar(dbfile,"MPI_nproc",&nproc);
  err += DBReadVar(dbfile,"NUM_FILES",&numfiles);
  if (err) {
    cout <<"must be serial file -- failed to find NUM_FILES and MPI_nproc\n";
    cout <<"continuing assuming serial file....\n";
    //rep.error("error reading params from file",fname);
    mpiPM.nproc=1; numfiles=1; ngroups=1;
  }
  else {
    cout <<"\tRead nproc="<<nproc<<"\tand numfiles="<<numfiles<<"\n";
    ngroups = nproc/numfiles;
    mpiPM.nproc = nproc;
  }
  DBClose(dbfile); dbfile=0; 
  
  *np = nproc;
  *nf = numfiles;
  return err;
}

int read_variable2grid(DBfile *dbfile,        ///< pointer to silo file.
		       const string variable, ///< variable name to read.
		       const long int npt     ///< number of cells expected.
		       )
{
  DBquadvar *silodata=0;
  silodata = DBGetQuadvar(dbfile,variable.c_str());
  if (!silodata)
    rep.error("dataio_silo::read_variable2grid() failed to read variable",variable);
  if (silodata->nels != npt)
    rep.error("dataio_silo::read_variable2grid() wrong number of cells",silodata->nels-SimPM.Ncell);

  FAKE_DOUBLE **data = (FAKE_DOUBLE **)(silodata->vals);

  if (variable=="Velocity" || variable=="MagneticField") {
    int v1,v2,v3;
    if (variable=="Velocity") {v1=VX;v2=VY;v3=VZ;}
    else                      {v1=BX;v2=BY;v3=BZ;}
    //    cout <<"name: "<<silodata->name<<"\tnels="<<silodata->nels<<endl;
    //    cout <<"ndims: "<<silodata->ndims<<"\tnvals: "<<silodata->nvals<<endl;
    //cout <<"reading variable "<<variable<<" into element "<<v1<<" of state vec.\n";
    cell *c=grid->FirstPt(); long int ct=0;
    do {
      if (point_on_my_domain(c)) {
	//      cout <<"ct="<<ct<<"\t and ncell="<<npt<<endl;
	c->P[v1] = data[0][ct];
	c->P[v2] = data[1][ct];
	c->P[v3] = data[2][ct];
	//c->P[v1] = silodata->vals[0][ct];
	//c->P[v2] = silodata->vals[1][ct];
	//c->P[v3] = silodata->vals[2][ct];
	//cout <<"ct="<<ct<<"\t and ncell="<<npt<<endl;
	ct++;
      }
    } while ( (c=grid->NextPt(c))!=0 );
    if (ct != npt) rep.error("wrong number of points read for vector variable",ct-npt);
  } // vector variable

  else {
    int v1=0;
    if      (variable=="Density")         v1=RO;
    else if (variable=="Pressure")        v1=PG;
    else if (variable=="VelocityX")       v1=VX;
    else if (variable=="VelocityY")       v1=VY;
    else if (variable=="VelocityZ")       v1=VZ;
    else if (variable=="MagneticFieldX")  v1=BX;
    else if (variable=="MagneticFieldY")  v1=BY;
    else if (variable=="MagneticFieldZ")  v1=BZ;
    else if (variable=="glmPSI")          v1=SI;
    //
    // Now loop over up to MAX_NVAR tracers...
    //
    else if (variable.substr(0,2)=="Tr") {
      int itr = atoi(variable.substr(2,3).c_str());
      if (!isfinite(itr) || itr<0 || itr>=MAX_NVAR) {
        rep.error("Bad diffuse Column-density identifier.",variable);
      }
      v1 = SimPM.ftr +itr;
    }
    //else if (variable.substr(0,3)=="Tr0") {v1=SimPM.ftr;}
    //else if (variable.substr(0,3)=="Tr1") {v1=SimPM.ftr+1;}
    //else if (variable.substr(0,3)=="Tr2") {v1=SimPM.ftr+2;}
    //else if (variable.substr(0,3)=="Tr3") {v1=SimPM.ftr+3;}
    //else if (variable.substr(0,3)=="Tr4") {v1=SimPM.ftr+4;}
    //else if (variable.substr(0,3)=="Tr5") {v1=SimPM.ftr+5;}
    //else if (variable.substr(0,3)=="Tr6") {v1=SimPM.ftr+6;}
    //else if (variable.substr(0,3)=="Tr7") {v1=SimPM.ftr+7;}
    //else if (variable.substr(0,3)=="Tr8") {v1=SimPM.ftr+8;}
    //else if (variable.substr(0,3)=="Tr9") {v1=SimPM.ftr+9;}
    else rep.error("what var to read???",variable);
    //cout <<"reading variable "<<variable<<" into element "<<v1<<" of state vec.\n";
    cell *c=grid->FirstPt(); long int ct=0;
    do {
      if (point_on_my_domain(c)) {
	//cout <<"val="<<silodata->vals[0][ct]<<" and data="<<data[0][ct]<<endl;
	//c->P[v1] = silodata->vals[0][ct];
	c->P[v1] = data[0][ct];
	ct++;
	//cout <<"ct="<<ct<<"\t and ncell="<<npt<<endl;
      }
    } while ( (c=grid->NextPt(c))!=0 );
    if (ct != npt) rep.error("wrong number of points read for scalar variable",ct-npt);
  } // scalar variable

  //  cout <<"Read variable "<<variable<<endl;
  DBFreeQuadvar(silodata); //silodata=0;
  data=0;
  return 0;
}

bool point_on_my_domain(const cell *c ///< pointer to cell
			)
{
  //
  // Assume point is on domain, and set to false if found to be off.
  //
  bool on=true;
  double dpos[SimPM.ndim]; CI.get_dpos(c,dpos);
  for (int i=0; i<SimPM.ndim; i++) {
    if (dpos[i]<mpiPM.LocalXmin[i]) on=false;
    if (dpos[i]>mpiPM.LocalXmax[i]) on=false;
  }
  return on;
}

void set_readvars(std::vector<string> &readvars ///< list of variables to add to.
		  )
{
  readvars.push_back("Density");
  readvars.push_back("Pressure");
#if defined (SILO_SCALARS)
  readvars.push_back("VelocityX");
  readvars.push_back("VelocityY");
  readvars.push_back("VelocityZ");
#elif defined (SILO_VECTORS)
  readvars.push_back("Velocity");
#else
#error "Must have either scalar components or vector variables defined!"
#endif
  // MHD has B-field, and maybe Psi for glm-mhd
  if (SimPM.eqntype==EQMHD || SimPM.eqntype==EQFCD || SimPM.eqntype==EQGLM) {
#if defined (SILO_SCALARS)
    readvars.push_back("MagneticFieldX");
    readvars.push_back("MagneticFieldY");
    readvars.push_back("MagneticFieldZ");
#elif defined (SILO_VECTORS)
    readvars.push_back("MagneticField");
#else
#error "Must have either scalar components or vector variables defined!"
#endif
    if (SimPM.eqntype==EQGLM) 
      readvars.push_back("glmPSI");
  }
  // if there are any tracer variables, get their names from SimPM.trtype
  if (SimPM.ntracer>0) {
    string s; ostringstream temp;
    for (int i=0; i<SimPM.ntracer; i++) {
      s.erase(); temp.str("");
      temp<< "Tr";
      temp.width(3); temp.fill('0'); temp << i;
      if (static_cast<int>(SimPM.trtype.size()) > 6*(i+1)) {
        temp<<"_"<< SimPM.trtype.substr(6*(i+1),6);
      }
      s=temp.str();
      // replace "+" with "p", and "-" with "m"
      string::size_type p=s.find("+");
      if (p!=string::npos) s.replace(p,1,"p");
      p=s.find("-");
      if (p!=string::npos) s.replace(p,1,"m");
      readvars.push_back(s);
      //      cout <<"tracer = "<<s<<endl;
    }
  } //tracers

  return;
} // set_readvars(vector<string>)




// ##################################################################
// ##################################################################




// stolen from gridMethods.cc
int setup_microphysics()
{
  cout <<"************************************************************\n";
  cout <<"***************** MICROPHYSICS SETUP ***********************\n";
  cout <<"************************************************************\n";
  //
  // Setup Microphysics class, if needed.
  // First see if we want the only_cooling class (much simpler), and if
  // not then check for the one of the bigger microphysics classes.
  //
  if (SimPM.EP.cooling && !SimPM.EP.chemistry) {
    cout <<"\t******* Requested cooling but no chemistry... setting";
    cout <<" up mp_only_cooling() class, with timestep-limiting.\n";
    SimPM.EP.MP_timestep_limit = 1;
    MP = new mp_only_cooling(SimPM.nvar, &(SimPM.EP));
    if (!MP) rep.error("mp_only_cooling() init",MP);
  }
  else if (SimPM.EP.chemistry) {
    //    MP = 0;
    cout <<"TRTYPE: "<<SimPM.trtype<<"\n";
    string mptype;
    if (SimPM.trtype.size() >=6)
      mptype = SimPM.trtype.substr(0,6); // Get first 6 chars for type of MP.
    else mptype = "None";
    bool have_set_MP=false;


#ifndef EXCLUDE_MPV1
    if      (mptype=="ChAH__" || mptype=="onlyH_") {
      cout <<"\t******* setting up MP_Hydrogen microphysics module *********\n";
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new MP_Hydrogen(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      cout <<"\t**---** WARNING, THIS MODULE HAS BEEN SUPERSEDED BY mp_implicit_H. **--**\n";
      have_set_MP=true;
    }
#endif // exclude MPv1


#ifndef EXCLUDE_HD_MODULE
    if (mptype=="lowZ__") {
      cout <<"\t******* setting up microphysics_lowz module *********\n";
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new microphysics_lowz(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      have_set_MP=true;
    }
#endif // exclude Harpreet's module

#ifndef EXCLUDE_MPV2
    if (mptype=="MPv2__") {
#ifdef MP_V2_AIFA
      cout <<"\t******* setting up mp_v2_aifa module *********\n";
      cout <<"\t******* N.B. Timestep limiting is enforced. **\n";
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new mp_v2_aifa(SimPM.nvar, SimPM.ntracer, SimPM.trtype);
      SimPM.EP.MP_timestep_limit = 1;
#else
      rep.error("Enable mp_v2_aifa as an ifdef if you really want to use it",2);
#endif
      have_set_MP=true;
    }
#endif // exclude MPv2


#ifndef EXCLUDE_MPV3
    if (mptype=="MPv3__") {
      cout <<"\t******* setting up mp_explicit_H module *********\n";
#if MPV3_DTLIMIT>=0 && MPV4_DTLIMIT<=12
      cout <<"\t******* N.B. Timestep limiting is enforced by #def";
      cout <<" MPV3_DTLIMIT="<<MPV3_DTLIMIT<<". **\n";
      SimPM.EP.MP_timestep_limit = 1;
      if (have_set_MP) rep.error("MP already initialised",mptype);
#else
#error "No timestep-limiting is defined in source/defines/functionality_flags.h"
#endif
      MP = new mp_explicit_H(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      //if (SimPM.EP.MP_timestep_limit != 1)
      //  rep.error("BAD dt LIMIT",SimPM.EP.MP_timestep_limit);
      have_set_MP=true;
    }
#endif // exclude MPv3


#ifndef EXCLUDE_MPV4
    if (mptype=="MPv4__") {
      cout <<"\t******* setting up mp_implicit_H module *********\n";
#if MPV4_DTLIMIT>=5 && MPV4_DTLIMIT<=12
      cout <<"\t******* N.B. dt05-12 Timestep limiting is enforced by #def";
      cout <<" DTLIMIT="<<MPV4_DTLIMIT<<". **\n";
      SimPM.EP.MP_timestep_limit =5;
#elif MPV4_DTLIMIT>=0 && MPV4_DTLIMIT<=4
      cout <<"\t******* N.B. dt00-04 Timestep limiting is enforced by #def";
      cout <<" MPV4_DTLIMIT="<<MPV4_DTLIMIT<<". **\n";
      SimPM.EP.MP_timestep_limit =4;
#else
#error "No timestep-limiting is defined in source/defines/functionality_flags.h"
#endif
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new mp_implicit_H(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      //SimPM.EP.MP_timestep_limit = 4;  // limit by recombination time only
      //if (SimPM.EP.MP_timestep_limit <0 || SimPM.EP.MP_timestep_limit >5)
      //  rep.error("BAD dt LIMIT",SimPM.EP.MP_timestep_limit);
      have_set_MP=true;
    }
#endif // exclude MPv4

    if (mptype=="MPv5__") {
      cout <<"\t******* setting up mpv5_molecular module *********\n";
      SimPM.EP.MP_timestep_limit = 1;
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new mpv5_molecular(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      have_set_MP=true;
    }

    if (mptype=="MPv6__") {
      cout <<"\t******* setting up mpv6_PureH module *********\n";
      SimPM.EP.MP_timestep_limit = 1;
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new mpv6_PureH(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      have_set_MP=true;
    }

    if (mptype=="MPv7__") {
      cout <<"\t******* setting up mpv7_TwoTempIso module *********\n";
      SimPM.EP.MP_timestep_limit = 1;
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new mpv7_TwoTempIso(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      have_set_MP=true;
    }

#ifdef CODE_EXT_HHE
    if (mptype=="MPv9__") {
      cout <<"\t******* setting up mpv9_HHe module *********\n";
      SimPM.EP.MP_timestep_limit = 1;
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new mpv9_HHe(SimPM.nvar, SimPM.ntracer, SimPM.trtype, 
                        &(SimPM.EP), SimPM.gamma);
      have_set_MP=true;
    }
#endif

#ifndef EXCLUDE_MPV1
    //
    // Finally, if MP has not been set up yet, try to set up the v0
    // microphysics integrator, which is slow, but can model a number
    // of elements and ions.
    //
    if (!have_set_MP) {
      cout <<"\t******* setting up MicroPhysics (v0) module *********\n";
      if (have_set_MP) rep.error("MP already initialised",mptype);
      MP = new MicroPhysics(SimPM.nvar, SimPM.ntracer, SimPM.trtype, &(SimPM.EP));
      if (SimPM.EP.MP_timestep_limit <0 || SimPM.EP.MP_timestep_limit >5)
        rep.error("BAD dt LIMIT",SimPM.EP.MP_timestep_limit);
      have_set_MP=true;
    }
#endif // exclude MPv1/0

    if (!MP) rep.error("microphysics init",MP);
    if (!have_set_MP) rep.error("HUH? have_set_MP",have_set_MP);
  }
  else {
    cout <<"\t******** not doing microphysics.\n";
    MP=0;
  }

  //
  // If we have a multifrequency ionising source, we can set its properties here.
  // We can only have one of these, so safe to just loop through...
  //
  //int err=0;
  //for (int isrc=0; isrc<SimPM.RS.Nsources; isrc++) {
  //  if (SimPM.RS.sources[isrc].type==RT_SRC_SINGLE &&
  //      SimPM.RS.sources[isrc].effect==RT_EFFECT_PION_MULTI &&
  //      MP!=0
  //      ) {
  //    err = MP->set_multifreq_source_properties(&SimPM.RS.sources[isrc]);
  //  }
  //}
  //if (err) rep.error("Setting multifreq source properties",err);
  

  cout <<"************************************************************\n";
  cout <<"***************** MICROPHYSICS SETUP ***********************\n";
  cout <<"************************************************************\n";
  return 0;
}


// ##################################################################
// ##################################################################



